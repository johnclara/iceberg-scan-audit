// used for symlinking
import java.nio.file.*

interface Module {
    String baseName()
    List<String> scalaVersions()
    String prefix()
    String pathPrefix()
}

class MockModule implements Module {
    String baseName
    List<String> scalaVersions = null

    @Override
    String baseName() {
        return baseName
    }

    @Override
    List<String> scalaVersions() {
        return scalaVersions
    }

    @Override
    String prefix() {
        return "mock-"
    }

    @Override
    String pathPrefix() {
        return "mock/"
    }
}

class IcebergAddonModule implements Module {
    String baseName
    List<String> scalaVersions = null

    @Override
    String baseName() {
        return baseName
    }

    @Override
    List<String> scalaVersions() {
        return scalaVersions
    }

    @Override
    String prefix() {
        return 'iceberg-addons' + "-"
    }

    @Override
    String pathPrefix() {
        return ""
    }
}

void includeModule(String moduleName, String sourcePath) {
    logger.info("Including module ${moduleName} at ${sourcePath}")
    include moduleName
    project(":${moduleName}").setProjectDir(new File(settingsDir, sourcePath))
}

void includeCrossBuildModules(
        String baseModuleName,
        String sourcePath,
        List<String> scalaVersions) {
    if (scalaVersions == null) {
        includeModule(baseModuleName, sourcePath)
    } else {
        /**
         * Intellij can't handle multiple modules with the same source. The following method is used to suggests versions during development.
         *
         * Provide a comma delimited String with scala versions in order of preference.
         * For modules with multiple scala versions, if any of them are in the list, then only the one with highest preference
         * will be included. If a module has multiple scala versions, but non of them are in the list then all will be included.
         */
        List<String> preferredScalaVersions = (properties.preferredScalaVersions == null) ? null : properties.preferredScalaVersions.toString().split(',')
        boolean crossBuiltModule = scalaVersions.size() > 1
        String preferredScalaVersion = (crossBuiltModule && preferredScalaVersions != null) ? preferredScalaVersions.find {v -> scalaVersions.contains(v) } : null
        List<String> includedScalaVersions = (preferredScalaVersion != null) ? [preferredScalaVersion] : scalaVersions

        includedScalaVersions.each { scalaVersion ->
            def moduleName = baseModuleName + "_" + scalaVersion
            includeModule(moduleName, sourcePath)
        }
    }

}

List<Module> modules = [
        new MockModule(baseName: "catalog"),
        new MockModule(baseName: "source", scalaVersions: ["2.11"]),
        new MockModule(baseName: "testkit"),
        new MockModule(baseName: "spark-testkit", scalaVersions: ["2.11"]),
        new IcebergAddonModule(baseName: 'bom'),
        new IcebergAddonModule(baseName: 'test-bom'),
        new IcebergAddonModule(baseName: 'catalog-lite'),
        new IcebergAddonModule(baseName: 'spark2-sanity-tests', scalaVersions: ['2.11']),
        new IcebergAddonModule(baseName: 'sanity-tests')
]

modules.each { module ->
    String moduleName = module.prefix() + module.baseName()
    String relativePath = module.pathPrefix() + module.baseName()

    includeCrossBuildModules(
            moduleName,
            relativePath,
            module.scalaVersions()
    )
}
